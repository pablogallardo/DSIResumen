\section{Unidad 2: Diseño de Sistemas de Información Orientado a Objetos con UML}
\subsection{Definición de Diseño, principios de diseño de software orientado a objetos}
\subsubsection{Definición}
Proceso mediante el cual se aplican varias técnicas y principios con el objetivo de definir un dispositivo, un proceso o un sistema con suficiente nivel de detalle como para permitir su realización física.\\ 
Proceso iterativo de transformar un modelo lógico en un modelo físico, teniendo en cuenta las restricciones del negocio.\\
\subsubsection{Concepto}
\begin{itemize}
\item Diseño es el proceso de decidir cómo se va a construir el producto final.
\begin{itemize}
\item Produce especificaciones completas y detalladas.
\end{itemize}
\item El seño define las partes principales del producto.
\begin{itemize}
\item Cuáles son esas partes.
\item Cómo interactúan.
\item Cómo se integran.
\end{itemize}
\item Los diseños imprecisos hacen perder tiempo de ingeniería.
\begin{itemize}
\item Se requerirá tiempo para completar los espacios vacíos en la especificación.
\item Las decisiones pueden no ser consistentes con la vista general del sistema.
\item Las incosistencias existentes puede que se detecten recién en la integración o prueba del sistema.
\end{itemize}
\end{itemize}
\clearpage
\subsubsection{Diferencias entre modelo de análisis y de diseño}
\begin{center}
\begin{tabu}{p{7cm}|p{7cm}}
\rowfont{\bfseries\itshape\large} Modelo de análisis & Modelo de diseño\\
\hline
\\[2pt]

Modelo conceptual, porque es una obstracción del sistema y permite aspectos de la implementación. &
Modelo físico, porque es un plano de la implementación.\\[2pt]
Genérico en cuanto al diseño. &
No genérico, específico para una implementación.\\[2pt]
Tres estereotipos conceptiales sobre las clases: Control, Entidad, Interfaz. &
Cualquier número de estereotipos (físicos) sobre las clases, dependiendo del lenguaje de implementación.\\[2pt]
Menos formal. &
Más formal.\\[2pt]
Menos claro de desarrollar. &
Más claro de desarrollar.\\[2pt]
Menos capas.&
Más capas.\\[2pt]
Dinámico y no muy centrado en la secuencia. &
Dinámico y muy centrado en la secuencia.\\[2pt]
Bosquejo del diseño del sistema, incluyendo su arquitectura.&
Manifiesto del diseño del sistema, incluyendo su arquitectura.\\[2pt]
Puede no estar mantenido durante todo el ciclo de vida del software. &
Debe ser mantenido durante todo el ciclo de vida del software.\\[2pt]
Define una estructura. &
Da forma al sistema preservando la estructura definida.
\end{tabu}
\end{center}
\subsubsection{Principios de diseño}
\paragraph{Características de un buen diseño}
\subparagraph{Identificación y tratamiento de excepciones}
\subparagraph{Independencia de componentes}
\subparagraph{Prevención y tolerancia de defectos}
\paragraph{Principios de diseño}
\subparagraph{Identificar los aspectos de la aplicación que varían y separarlas de las que son estables}
Hay partes del código que son más probables de que cambien con cada nuevo requerimiento del cliente, por lo tanto, es un comportamiento que debe ser separado de lo que no cambia.
\subparagraph{Programar hacia una interfaz, no una implementación}
Para hacer un programa flexible es recomendable usar supertipos (Interfaces o Clases Abstractas). El punto es explotar el polimorfismo. De esta manera, el objeto en tiempo de ejecución no está ligado al código.
\subparagraph{Favorecer la composición sobre la herencia}
Crear sistemas usando la composición nos da mucha flexibilidad. No solo nos deja encapsular una familia de algoritmos en distintas clases, sino también \emph{cambiar el comportamiento en tiempo de ejecución} siempre y cuando el objeto con el que estamos ``componiento'' implemente la interfaz de comportamiento apropiada.
\subparagraph{\emph{Luchar} por obtener diseños de bajo acoplamiento entre objetos que interactúan}
Diseños de bajo acoplamiento nos permite construir sistemas orientados a objetos flexibles que pueden lidiar con cambios de manera eficiente porque minimizan la interdependencia entre objetos.
\subparagraph{Las clases deben estar abiertas para la extensión y cerradas para la modificación}
El propósito es permitir la expansión de las clases para que puedan incorporar nuevos comportamientos sin modificar el código existente. De esta manera, se evitan errores que se puedan introducir al código que ya ha sido probado y optimizado.
\subparagraph{Depender de abstracciones, no de clases concretas}
Esto sugiere que nuestros componentes de alto nivel no deberían depender de los de bajo nivel. Ambos deberían depender de abstracciones.
\subparagraph{Principio del menor conocimiento - Habla solo con tus amigos inmediatos}
Este principio nos ayuda a prevenir diseños que tienen muchas clases acopladas que, si cambian en una parte del sistema, tiene que haber cambios en cascada a las partes subsiguientes. El principio dice que solo deberíamos invocar un método en un objeto si pertenece a:
\begin{itemize}
\item El objeto mismo.
\item Objetos pasados por parámetros al método.
\item Cualquier objeto en donde el método crea instancias.
\item Cualquier componente del objeto.
\end{itemize}
\subparagraph{El principio de Hollywood - No nos llames, nostros te llamaremos}
Nos ayuda a prevenir la degradación de dependencias. Esto pasa cuando tenemos componentes de alto nivel dependiendo de componentes de bajo nivel y estos, a su vez, dependen de componentes de alto nivel y estos dependen de otros componentes del mismo nivel y estos dependen de otros componentes de bajo nivel y así sucesivamente. Con este principio permitimos que los componentes de bajo nivel se relaciones entre sí formando un sistema y que los componentes de alto nivel determinen cuándo son necesarios y cómo.
\subparagraph{Principio de Responsabilidad Única - Una clase debería tener solamente una razón para cambiar}
Cuando se modifica el código de una clase se incrementan las oportunidades de introducir problemas. Teniendo dos razones para cambiar una clase hay más probabilidades de que este cambio introduzca problemas a los dos aspectos del diseño de la misma. Este principio nos guía para asignar cada responsabilidad a una clase y solo una clase.
\subparagraph{No te repitas}
Evitar la duplicación del código abstrayendo lo común y poniéndolo en un solo lugar
\subparagraph{Principio de Liskov}
Los subtipos deben ser sustituibles por sus tipos base. Este principio nos ayuda a plantear buenas herencias.
\subsection{Aspectos que se diseñan en un sistema de información}
\paragraph{Diseño arquitectónico}
Define la relación entre los principales elementos estructurales del programa.
\paragraph{Diseño de datos}
Transforma los requerimientos en las estructuras de datos necesarias para implementar el software.
\paragraph{Diseño de los procesos}
Transforma elementos estructurales de la arquitectura del programa en una descripción procedimental de los componentes del software.
\paragraph{Diseño de la interfaz}
Describe cómo se comunica el software consigo mismo, con los sistemas que operan en él, con los dispositivos externos y con los usuarios.
\paragraph{Diseño de formas de entrada/salida}
Describe cómo se ingresa información al software y cómo se presentarán las salidas del mismo.
\paragraph{Diseño de procediminetos manuales}
Describe cómo integra el software al Sistema de Negocio.
\subsection{Estrategias de Prototipado y de Ensamblaje de Componentes}
\subsubsection{Estrategia de prototipado}
\paragraph{Definición}
Es una elección del modelo de proceso que se recomienda elegir a la hora de implementar un proyecto complejo, con dominio no familiar, que utilizará una tecnología desconocida; de ahí que surge la necesidad de requirirse el uso de prototipos en el diseño y la implementación, además de utilizarlos durante la validación de requerimientos.
\begin{itemize}
\item Es un modo de desarrollo de software.
\item El prototipo es una aplicación que funciona.
\item La finalidad del prototipo es probar varias suposiciones formuladas por analistas y usuarios con respecto a las características requeridas del sistema.
\item Los prototipos se crean con rapidez, evolucionan a través de un proceso interactivo y tienen un bajo costo de desarrollo.
\end{itemize}
\paragraph{Concepto}
\begin{itemize}
\item Primera versión de un nuevo tipo de producto, en el que se han incorporado solo algunas características del sistema final, o no se han realizado completamente.
\item Modelo o maqueta del sistema que se construye para complender mejor el problema y sus posibles soluciones:
\begin{itemize}
\item Evaluar mejor los requisitos.
\item Probar opciones de diseño.
\end{itemize}
\end{itemize}
\paragraph{Características de los prototipos}
\begin{itemize}
\item Funcionalidad limitada.
\item Poca fiabilidad.
\item Características de operación pobres.
\item Prototipo aproximado de 10\% del presupuesto del proyecto.
\end{itemize}
\paragraph{Objetivo}
\begin{itemize}
\item Aclarar los requerimientos de los usuarios.
\item Verificar la factibilidad del diseño del sistema.
\end{itemize}
\paragraph{Cuándo es conveniente usarlos}
Siempre es conveniente pero especialmente cuando:
\begin{itemize}
\item El Área de aplicación no está bien definida.
\item El costo del rechazo por parte de los usuarios, por no cumplir sus expectativas, es muy alto.
\item Es necesario evaluar previamente el impacto del sistema en los usuarios y en la organización.
\item Se usan nuevos métodos, técnicas, tecnología.
\item No se conocen los requerimientos o es necesario realizar una evaluación de los requerimientos.
\item Cuando los costos de inversión son altos.
\item Cuando hay factores de riesgo alto asociados al proyecto.
\end{itemize}
\paragraph{Uso de los prototipos} \hspace{0pt}\\
Para el cliente:
\begin{itemize}
\item Ayuda a establecer claramente los requisitos.
\end{itemize}
Para los desarrolladores:
\begin{itemize}
\item Validar corrección de la especificación.
\item Aprender sobre problemas que se presentarán durante el diseño e implementación del sistema.
\item Mejorar el producto.
\item Examinar viabilidad y utilidad de la aplicación.
\end{itemize}
\paragraph{Beneficios}
\begin{itemize}
\item Aumentar la productividad.
\item Desarrollo planificado.
\item Entusiasmo de los usuarios respecto a los prototipos.
\end{itemize}
\paragraph{Tipos de prototipos}
\begin{description}
\item[Prototipado de interfaz de usuario:] Modelos de pantallas.
\item[Prototipado funcional (Operacional):] Implementa algunas funciones y a medida que se comprueba que son las apropiadas, se ocrrigen, refinan y se añaden otras.
\item[Modelos de rendimiento:] Evalúan el rendimiento de una aplicación crítica (no sirven al análisis de requisitos).
\end{description}
\paragraph{Desde el punto de vista de la utilidad, los prototipos pueden construirse:}
\begin{itemize}
\item Rápido o desechable:
\begin{itemize}
\item Sirve al análisis y validación de los requisitos.
\item Después se redacta la especificación del sistema y se desecha el prototipo.
\item La aplicación se desarrolla siguiendo un paradigma diferente.
\item Puede ser un problema cuando el prototipo no se desecha y termina convirtiéndose en el sistema final.
\end{itemize}
\item Evolutivos
\begin{itemize}
\item Comienza con un sistema relativamente simple que implementa los requisitos más importantes o mejor conocidos.
\item El prototipo se aumenta o cambia en cuanto se descubren nuevos requisitos.
\item Finalmente, se convierte en el sistema requerido.
\item Actualmente se usa en el desarrollo de sitios Web y en aplicaciones de comercio electrónico.
\end{itemize}
\end{itemize}
\paragraph{Con respecto al alcance, los prototipos pueden clasificarse en:}
\begin{description}
\item[Vertical] Desarrolla completamente alguna de las funciones.
\item[Horizontal] Desarrolla parcialmente todas las funciones.
\end{description}
\paragraph{Etapas del método con prototipos}
\begin{enumerate}
\item Identificación de requerimientos conocidos.
\item Desarrollo de un modelo de trabajo.
\item Participación del usuario.
\item Revisión del prototipo.
\item Iteración del proceso de refinamiento.
\end{enumerate}
\paragraph{Estrategias para el desarrollo de prototipos}
\begin{description}
\item[Prototipos para pantallas] El elemento clave es el intercambio de información con el usuario.
\item[Prototipos para procedimientos de procesamiento] El prototipo incluye solo procesos sin considerar errores.
\item[Prototipos para funciones básicas] Solo se desarrolla el núcleo de la aplicación, es decir solo los procesos básicos.
\end{description}
\paragraph{Tareas para los usuarios}
\begin{itemize}
\item Identificar la finalidad del sistema.
\item Describir la salida del sistema.
\item Describir los requerimientos de datos.
\item Utilizar y evaluar el prototipo.
\item Identificar las mejoras necesarias.
\item Documentar las características no deseables.
\end{itemize}
\paragraph{Críticas}
\begin{itemize}
\item El cliente cree que es el sistema funcional.
\item Peligro de familiarización con malas elecciones iniciales.
\item Difícil de administrar: se necesita mucha experiencia.
\item Alto costo
\end{itemize}
\subsubsection{Estrategia de Ensamblaje de Componentes}
\begin{itemize}
\item Es un modelo evolutivo de desarrollo de software.
\item El modelo de ensamblaje de componentes incorpora muchas de las características del modelo en espiral.
\item Es evolutivo por naturaleza y exige un enfoque iterativo para la creación del software.
\item Configura aplicaciones desde componentes preparados de software (COTS).
\end{itemize}
\paragraph{En qué consiste}
\begin{itemize}
\item Identificar las clases candidatas. Se lleva a cabo examinando los datos que se van a manejar por parte de la aplicación y el algoritmo que se va a aplicar para conseguir el tratamiento.
\item Las clases creadas en los proyectos de ingeniería del software anteriores se almacenan en una biblioteca de clases.
\item La biblioteca de clases se examina para determinar si estas clases ya existe.
\end{itemize}
\paragraph{Niveles}
\begin{itemize}
\item De aplicación, en el que una aplicación completa se integra con el prototipo.
\item De componente, en el que los componentes se integran en un marco de trabajo estándar.
\end{itemize}
\paragraph{Beneficios}
Según estudios de reutilización, el ensamblaje de componentes lleva a una reducción del 70\% de tiempo de ciclo de desarrollo, un 84\% del coste del proyecto y un índice de productividad del 26,2\%.
\paragraph{Ventajas de usar el Desarrollo de software basado en componentes}
\begin{description}
\item[Reutilización del software] Nos lleva a alcanzar un mayor nivel de reutilización de software.
\item[Simplifica las pruebas] Permite que las pruebas sean ejecutadas probando cada uno de los componentes antes de probar el conjunto completo de componentes ensamblados.
\item[Simplifica el mantenimiento del sistema] Cuando existe un débil acoplamiento entre componentes, el desarrollador es libre de actualizar y/o agregar componentes segñun sea necesario sin afectar otras partes del sistema.
\item[Mayor calidad] Dado que un componente puede ser construido y luego mejorado continuamente por un experto u organización, la calidad de una aplicación basada en componentes mejorará con el paso del tiempo.
\end{description}

\paragraph{Ventajas de usar componentes de terceros:}
\begin{description}
\item[Ciclos de desarrollo más cortos] La adicción de una pieza dada de funcionalidad tomará días en lugar de meses o años.
\item[Mejor ROI] Usando correctamente esta estrategia, el retorno sobre la inversión puede ser más favorable que desarrollando los componentes uno mismo.
\item[Funcionalidad mejorada] Para usar un componente que contenga una pieza de funcionalidad, solo se necesita entender su naturaleza, más no sus detalles internos.
\end{description}

\subsection{Diseño en el Proceso Unificado de Desarrollo}
\subsubsection{Objetivo}
\begin{itemize}
\item Aquirir una comprensión en profundidad de los aspectos relacionados con los requisitos no funcionales y restricciones relacionadas con los lenguajes de programación, componentes reutilizables, sistemas operativos, tecnologías, etc.
\item Crear una entrada apropiada y un punto de partida para actividades de implementación subsiguientes capturando los requisitos o subsistemas individuales, interfaces y clases.
\item Ser capaces de descomponer los trabajos de implementación en partes más manejables que puedan ser llevadas a cabo por diferentes equipos de desarrollo teniendo en cuenta la posible concurrencia.
\end{itemize}
\subsubsection{El papel del diseño en el ciclo de vida del software}
El diseño es el centro de atención al final de la fase de elaboración y el comienzo de las iteraciones de construcción. El diseño está muy cercando al de implementación, lo que es natural para guardar y mantener el modelo de diseño a través del ciclo de vida completo del software.
\subsubsection{Artefactos}
\paragraph{Modelo de diseño}
Es un modelo de objetos que describe la realización física de los casos de uso centrándose en cómo los requisitos funcionales y no funcionales, junto con otras restricciones relacionadas con el entorno de implementación, tienen impacto en el sistema a considerar.
\paragraph{Clase de diseño}
Es una abstracción sin costuras de una clase o construcción similar en la implementación del sistema.
\paragraph{Realización de caso de uso de diseño}
Es una colaboración en el modelo de diseño que describe cómo se realiza un caso de uso específico y como se ejecuta en términos de clase de diseño y sus objetivos. Proporciona una traza directa a una realización de caso de uso de análisis en el modelo de análisis.
\subparagraph{Diagramas de clases}
Es una clase de diseño y sus objetivos.
\subparagraph{Diagramas de interacción}
La secuencia de acciones en un caso de uso comienza cuando un actor invoca el caso de uso mediante el envío de algún tipo de mensaje al sistema.
\subparagraph{Flujo de sucesos de diseño}
Es una descripción textual que explica y complementa a los diagramas y a sus etiquetas.
\subparagraph{Requisitos de la implementación}
Son una descripción textual que recoge requisitos tales como los requisitos no funcionales sobre una realización de caso de uso.
\paragraph{Subsistema de diseño}
Son una forma de organizar los artefactos del modelo de diseño en piezas más manejables.
\subparagraph{Subsistemas de servicio}
Se utilizan en un nivel inferior de la jerarquía de subsistemas de diseño para aislar los cambios en los correspondientes subsistemas de servicio.
\paragraph{Interfaz}
Las interfaces se utilizan para especificar las operaciones que proporcionan las clases y los subsistemas del disñeo.
\paragraph{Descripción de la arquitectura (Vista del modelo de diseño)}
Muestra los artefactos del modelo de diseño relevantes para la arquitectura.
\begin{itemize}
	\item La descomposición del modelo de diseño en subsistemas, sus interfaces y las dependencias entre ellos.
	\item Clases del diseño fundamentales.
	\item Realizaciones de caso de uso de diseño que describen alguna funcionalidad importante y crítica que debe desarrollarse pronto dentro del ciclo de vida del software.
\end{itemize}
\paragraph{Modelo de despliegue}
Es un modelo de objetos que describe la distribución física del sistema en términos de cómo se distribuye la funcionalidad entre los nodos del cómputo.
\paragraph{Descripción de la arquitectura (Vista del modelo de despliegue}
Contiene una vista de la arquitectura del modelo de despliegue que muestra sus artefactos relevantes para la arquitectura.
\subsubsection{Trabajadores}
\paragraph{Ingeniero de casos de uso}
Es responsable de la integridad de una o más realizaciones de casos de uso de diseño y debe garantizar que cumplen los requisitos que se esperan de ellos.
\paragraph{Ingeniero de componentes}
Define y mantiene las operaciones, métodos, atributos, relaciones y requisitos de implementación de una o más clases del diseño garantizando que cada clase del diseño cumple los requisitos que se esperan de ella según las realizaciones de caso de uso en las que participa.
\subsubsection{Actividades}
\paragraph{Diseño de la arquitectura}
Su objetivo es esbozar los modelos de diseño y despliegue y su arquitectura mediante la identificación de los siguientes elementos:
\begin{itemize}
	\item Nodos y sus configuraciones.
	\item Subsistemas y sus interfaces.
	\item Clases del diseño significativas para la arquitectura.
	\item Mecanismos de diseño genéricos que tratan requisitos comunes.
\end{itemize}
\paragraph{Diseño de un caso de uso}
Los objetivos de esta actividad son:
\begin{itemize}
	\item Identificar las clases del diseño y/o los subsistemas cuyas instancias son necesarias para llevar a cabo el flujo de sucesos del caso de uso.
	\item Distribuir el comportamiento del caso de uso entre los objetos del diseño que interactúan y/o entre los subsistemas participantes.
	\item Definir los requisitos sobre las operaciones de las clases del diseño y/o sobre los subsistemas y sus interfaces.
	\item Capturar los requisitos de implementación del caso de uso.
\end{itemize}
\paragraph{Diseño de una clase}
El objetivo es crear una clase del diseño que cumpla su papel en las realizaciones de los casos de uso y los requisitos no funcionales que se aplican a estos.
\paragraph{Diseño de un subsistema}
Los objetivos de esta actividad son:
\begin{itemize}
	\item Garantizar que el subsistema es tan independiente como sea posible de otros subsistemas y/o de sus intereses.
	\item Garantizar que el subsistema proporciona las interfaces correctas.
	\item Garantizar que el subsistema cumple su propósito de ofrecer una realización correcta de las operaciones tal y como se definen en las interfaces que proporciona.
\end{itemize}
\subsection{Diseño del Software Orientado a Objetos}
\subsubsection{Diseño del Comportamiento del Software}
Se refieren a algoritmos y asignación de responsabilidades a objetos.
\subsubsection{Diseño de la Estructura del Software}
Se refiere a cómo se combinan las clases y los objetos para formar estructuras más grandes.
\subsubsection{Patrones de diseño}
\paragraph{Introducción}
Los patrones de diseño ayudan a diseñar software orientado a objetos reutilizable. Estos patrones resuelven problemas concretos de diseño y hacen que los diseños orientados a objetos sean más flexibles, elegantes y reutilizables.\\
Cada patrón nomina, explica y evalúa un diseño importante y recurrente en los sistemas orientados a objetos. Pueden incluso mejorar la documentación y el mantenimiento de los sistemas existentes al proporcionar una especificación explícita de las interacciones entre clases y objetos.
\paragraph{¿Qué son los Patrones de Diseño?}
Son descripciones de clases y objetos relacionados que están particularizados para resolver un problema de diseño general en un determinado contexto.
\paragraph{Tipos de Patrones de Diseño}
\subparagraph{Patrones de Creación}
Los patrones de creación tienen que ver con el proceso de creación de objetos. Los patrones de creación de clases delegan alguna parte del proceso de creación de objetos en las subclases, mientras que los patrones de creación de objetos lo hacen en otro objeto. 
\subparagraph{Patrones Estructurales}
Los patrones estructurales tratan con la composición de clases u objetos. Los patrones estructurales de clases usan la herencia para componer clases, mientras que los de objetos describen formas de ensamblar objetos.
\subparagraph{Patrones de Comportamiento}
Caracterizan el modo en que las clases y objetos interactúan y se reparten la responsabilidad. Los patrones de comportamiento de clases usan la herencia para describir algoritmos y flujos de control, mientras que los de objetos describen cómo cooperan un grupo de objetos para realizar una tarea que ningún objeto puede llevar a cabo por sí solo.
\paragraph{Patrones de Diseño de Creación}
\subparagraph{Singleton}
El patrón de diseño singleton (instancia única) está diseñado para restringir la creación de objetos pertenecientes a una clase o el valor de un tipo a un único objeto.\\
Su intención consiste en garantizar que una clase sólo tenga una instancia y proporcionar un punto de acceso global a ella.\\
El patrón singleton se implementa creando en nuestra clase un método que crea una instancia del objeto sólo si todavía no existe alguna. Para asegurar que la clase no puede ser instanciada nuevamente se regula el alcance del constructor (con atributos como protegido o privado).\\
Las situaciones más habituales de aplicación de este patrón son aquellas en las que dicha clase controla el acceso a un recurso físico único (como puede ser el ratón o un archivo abierto en modo exclusivo) o cuando cierto tipo de datos debe estar disponible para todos los demás objetos de la aplicación.\\
\begin{figure}
  \centering
    \includegraphics[width=0.5\textwidth]{singleton}
\end{figure}
\subparagraph{Abstract Factory}
Contexto: Debemos crear diferentes objetos, todos pertenecientes a la misma familia. Por ejemplo: las bibliotecas para crear interfaces gráficas suelen utilizar este patrón y cada familia sería un sistema operativo distinto. Así pues, el usuario declara un Botón, pero de forma más interna lo que está creando es un BotónWindows o un BotónLinux, por ejemplo.\\
El problema que intenta solucionar este patrón es el de crear diferentes familias de objetos.\\
El patrón Abstract Factory está aconsejado cuando se prevé la inclusión de nuevas familias de productos, pero puede resultar contraproducente cuando se añaden nuevos productos o cambian los existentes, puesto que afectaría a todas las familias creadas\\
\begin{figure}[h!]
  \centering{}
    \includegraphics[width=1\textwidth]{abstract_factory}
\end{figure}
\newpage
\subparagraph{Factory Method}
El patrón de diseño Factory Method consiste en utilizar una clase constructora (al estilo del Abstract Factory) abstracta con unos cuantos métodos definidos y otro(s) abstracto(s): el dedicado a la construcción de objetos de un subtipo de un tipo determinado. Es una simplificación del Abstract Factory, en la que la clase abstracta tiene métodos concretos que usan algunos de los abstractos; según usemos una u otra hija de esta clase abstracta, tendremos uno u otro comportamiento.
\begin{figure}[h!]
  \centering{}
    \includegraphics[width=1\textwidth]{factory_method}
\end{figure}
\subparagraph{Builder}
El patrón builder (Constructor) es usado para permitir la creación de una variedad de objetos complejos desde un objeto fuente (Producto), el objeto fuente se compone de una variedad de partes que contribuyen individualmente a la creación de cada objeto complejo a través de un conjunto de llamadas a interfaces comunes de la clase Abstract Builder.\\
Intención: Abstrae el proceso de creación de un objeto complejo, centralizando dicho proceso en un único punto, de tal forma que el mismo proceso de construcción pueda crear representaciones diferentes.\\
\begin{figure}[h!]
  \centering{}
    \includegraphics[width=1\textwidth]{builder}
\end{figure}
\subparagraph{Prototype}
El patrón de diseño Prototype (Prototipo), tiene como finalidad crear nuevos objetos duplicándolos, clonando una instancia creada previamente.\\
Este patrón especifica la clase de objetos a crear mediante la clonación de un prototipo que es una instancia ya creada. La clase de los objetos que servirán de prototipo deberá incluir en su interfaz la manera de solicitar una copia, que será desarrollada luego por las clases concretas de prototipos.
\begin{figure}[h!]
  \centering{}
    \includegraphics[width=1\textwidth]{prototype}
\end{figure}
\newpage
\paragraph{Patrones de Estructura}
\subparagraph{Adapter}
El patrón Adapter (Adaptador) se utiliza para transformar una interfaz en otra, de tal modo que una clase que no pudiera utilizar la primera, haga uso de ella a través de la segunda.
\begin{figure}[h!]
  \centering{}
    \includegraphics[width=1\textwidth]{adapter}
\end{figure}
\subparagraph{Bridge}
l patrón Bridge, también conocido como Handle/Body, es una técnica usada en programación para desacoplar una abstracción de su implementación, de manera que ambas puedan ser modificadas independientemente sin necesidad de alterar por ello la otra.\\
Esto es, se desacopla una abstracción de su implementación para que puedan variar independientemente.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1.2\textwidth]{bridge}}
\subparagraph{Composite}
El patrón Composite sirve para construir objetos complejos a partir de otros más simples y similares entre sí, gracias a la composición recursiva y a una estructura en forma de árbol.\\
Esto simplifica el tratamiento de los objetos creados, ya que al poseer todos ellos una interfaz común, se tratan todos de la misma manera.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{composite}}
\subparagraph{Decorator}
El patrón Decorator responde a la necesidad de añadir dinámicamente funcionalidad a un Objeto. Esto nos permite no tener que crear sucesivas clases que hereden de la primera incorporando la nueva funcionalidad, sino otras que la implementan y se asocian a la primera.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{decorator}}
\subparagraph{Facade}
El patrón fachada viene motivado por la necesidad de estructurar un entorno de programación y reducir su complejidad con la división en subsistemas, minimizando las comunicaciones y dependencias entre éstos.\\
Se aplicará el patrón fachada cuando se necesite proporcionar una interfaz simple para un subsistema complejo, o cuando se quiera estructurar varios subsistemas en capas, ya que las fachadas serían el punto de entrada a cada nivel. Otro escenario proclive para su aplicación surge de la necesidad de desacoplar un sistema de sus clientes y de otros subsistemas, haciéndolo más independiente, portable y reutilizable (esto es, reduciendo dependencias entre los subsistemas y los clientes).\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{facade}}
\subparagraph{Flyweight}
El patrón Flyweight (u objeto ligero) sirve para eliminar o reducir la redundancia cuando tenemos gran cantidad de objetos que contienen información idéntica, además de lograr un equilibrio entre flexibilidad y rendimiento (uso de recursos).\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{flyweight}}
\subparagraph{Proxy}
El patrón Proxy es un patrón estructural que tiene como propósito proporcionar un subrogado o intermediario de un objeto para controlar su acceso.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{proxy}}
\paragraph{Patrones de Comportamiento}
\subparagraph{Template Method}
Es un patrón de diseño enmarcado dentro de los llamados patrones de comportamiento, que se caracteriza por la definición, dentro de una operación de una superclase, de los pasos de un algoritmo, de forma que todos o parte de estos pasos son redefinidos en las subclases herederas de la citada superclase.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{template_method}}
\subparagraph{Chain of Responsability}
Es un patrón de comportamiento que evita acoplar el emisor de una petición a su receptor dando a más de un objeto la posibilidad de responder a una petición. Para ello, se encadenan los receptores y pasa la petición a través de la cadena hasta que es procesada por algún objeto. Este patrón es utilizado a menudo en el contexto de las interfaces gráficas de usuario donde un objeto puede contener varios objetos. Según si el ambiente de ventanas genera eventos, los objetos los manejan o los pasan.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{chain_of_responsability}}
\subparagraph{Command}
Este patrón permite solicitar una operación a un objeto sin conocer realmente el contenido de esta operación, ni el receptor real de la misma. Para ello se encapsula la petición como un objeto, con lo que además se facilita la parametrización de los métodos.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{command}}
\subparagraph{Iterator}
define una interfaz que declara los métodos necesarios para acceder secuencialmente a un grupo de objetos de una colección.\\
Este patrón de diseño permite recorrer una estructura de datos sin que sea necesario conocer la estructura interna de la misma.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{iterator}}
\subparagraph{Mediator}
El patrón mediador define un objeto que encapsula cómo un conjunto de objetos interactúan. Este patrón de diseño está considerado como un patrón de comportamiento debido al hecho de que puede alterar el comportamiento del programa en ejecución.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{mediator}}
\subparagraph{Memento}
Memento, es un patrón de diseño, cuya finalidad es almacenar el estado de un objeto (o del sistema completo) en un momento dado de manera que se pueda restaurar en ese punto de manera sencilla. Para ello se mantiene almacenado el estado del objeto para un instante de tiempo en una clase independiente de aquella a la que pertenece el objeto (pero sin romper la encapsulación), de forma que ese recuerdo permita que el objeto sea modificado y pueda volver a su estado anterior.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{memento}}
\subparagraph{Observer}
Definir una dependencia uno-a-muchos entre objetos, de tal forma que cuando el objeto cambie de estado, todos sus objetos dependientes sean notificados automáticamente. Se trata de desacoplar la clase de los objetos clientes del objeto, aumentando la modularidad del lenguaje, creando las mínimas dependencias y evitando bucles de actualización (espera activa o polling). En definitiva, normalmente, usaremos el patrón Observador cuando un elemento tiene que estar pendiente de otro, sin tener que estar encuestando de forma permanente si éste ha cambiado o no.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{observer}}
\subparagraph{State}
En determinadas ocasiones, cuando el contexto en el que se está desarrollando requiere que un objeto tenga diferentes comportamientos según el estado en que se encuentra, resulta complicado poder manejar el cambio de comportamientos y los estados de dicho objeto, todos dentro del mismo bloque de código. El patrón State propone una solución a esta complicación, creando básicamente, un objeto por cada estado posible del objeto que lo llama.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{state}}
\subparagraph{Strategy}
El patrón estrategia permite mantener un conjunto de algoritmos de entre los cuales el objeto cliente puede elegir aquel que le conviene e intercambiarlo dinámicamente según sus necesidades.\\
\vspace*{\fill}
\noindent\makebox[\textwidth]{\includegraphics[width=1\textwidth]{strategy}}
\subsection{Mapeo de estructuras de clases a bases de datos relacionales}
\subsubsection{Problema de la impedancia}
En una base de datos relacional, la información se almacena en tablas. Los tipos a ser usados en las tablas son mayormente los tipos primitivos. Esto trae problemas al almacenar objetos.
\begin{itemize}
\item Los datos pueden almacenarse y no el comportamiento.
\item Solo los tipos de datos primitivos pueden almacenarse y no las estructuras complejas.
\end{itemize}
En vista de los problemas enunciados, necesitamos transformar nuestra estructura de información de objeto a una estructura orientada a tablas. Este problema se refiere a veces como el problema de la impedancia.\\
El problema de la impedancia trata aún otro problema: crea un fuerte acoplamiento entre la aplicación y el DBMS.\\
\subsection{Herencia}
Los objetos que deberían ser persistentes deberían ser mapeados en tablas de la base de datos. Se las clases se heredan unas a otras, hay principalmente dos maneras diferentes de resolver esto:
\begin{enumerate}
\item Los atributos heredados se copian a todas las tablas que representan las clases descendientes. Ninguna tabla representará la clase abstracta. \emph{Se elimina al ``padre''}.
\item La clase abstracta está en su propia tabla, a la que las tablas de las clases descendientes hacen referencia.
\end{enumerate}
¿Cuál alternativa es la mejor? No hay una mejor solución general para todos los casos, pero vamos a resaltar algunas de las propiedades de ambas alternativas. La primera es normalmente más rápida dado que no es necesario ningún joining o búsqueda en varias tablas para obtener información de un objeto.. Sin embargo, el tamaño de la base de datos aumentará dado que las columnas heredadas deben duplicarse. Además, si los cambios ocurren en los atributos heredados, los mismos afectarán a las tablas de todas las clases descendientes. En esta solución no tenemos ningún conocimiento de qué columnas se representan en la tabla que representa la clase abstracta. Una tabla específica que registre las diversas columnas sería entonces necesaria.\\
La segunda alternativa incluye menos redundancia, pero puede conducir a problemas si los identificadores son comunes en la tabla de la clase abstracta. Por ejemplo, si tenemos una clase abstracta persona; y estudiante y profesor son descendientes, entonces ninguna persona puede ser estudiante y profesor a la vez.
\subsection{Diseño de Interfaces de Usuario}
Para que un sistema alcance su potencial máximo es fundamental que su interfaz de usuario sea diseñada para ajustarse a las habilidades, experiencia y expectativas de sus usuarios previstos. Un buen diseño de la interfaz es crítico para la confiabilidad del sistema. Muchos de los llamados errores de usuario son causados por el hecho de que las interfaces de usuario no consideran las habilidades de los usuarios reales y su entorno de trabajo.\\
\subsubsection{Factores a tener en cuenta}
\begin{enumerate}
\item Las personas tienen una memoria limitada a corto plazo.
\item Todos cometemos errores, especialmente cuando tenemos que manejar demasiada información o estamos estresados.
\item Poseemos un amplio rango de capacidades físicas.
\item Tenemos diferentes preferencias de interacción.
\end{enumerate}
\subsubsection{Principios de diseño de interfaces gráficas}
\begin{tabu}{p{7cm}|p{7cm}}
\rowfont{\bfseries\itshape\large} Principio & Descripción\\
\hline
\\[2pt]

Familiaridad de usuario. &
La interfaz debe utilizar términos y conceptos obtenidos de la experiencia de las personas que más utilizan el sistema.\\[2pt]
Uniformidad. &
Siempre que sea posible, la interfaz debe ser uiforme en el sentido de que las operaciones comparables se activen de la misma forma.\\[2pt]
Mínima sorpresa &
El comportamiento del sistema no debe provocar sorpresa a los usuarios.\\[2pt]
Recuperabilidad. &
La interfaz debe incluir mecanismos para permitir a los usuarios recuperarse de los errores.\\[2pt]
Guía de usuario. &
Cuando ocurran errores, la interfaz debe proporcionar retroalimentación significativa y características de ayuda sensible al contexto.\\[2pt]
Diversidad de usuarios. &
La interfaz debe proporcionar características de interacción apropiadas para los diferentes tipos de usuarios del sistema.
\end{tabu}
\end{center}

\subsubsection{Recursos de recuperación de errores}
\begin{enumerate}
\item Confirmación de acciones destructivas.
\item Proporcionar un recurso para deshacer.
\item Generar puntos de control.
\end{enumerate}
